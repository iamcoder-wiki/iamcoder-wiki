<!doctype html>
<html lang="ko" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    
    <meta property="og:title" content="Topological Sort - IamCoder Wiki"/>
    <title>Topological Sort - IamCoder Wiki</title>
    <link rel="stylesheet" href="/r/css/style.css">
    <link rel="stylesheet" href="/r/css/variable.css">
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/androidstudio.min.css"
          id="r-dark">
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.2/build/styles/atelier-forest-light.min.css"
          id="r-light" disabled>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css">
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300;0,400;0,600;0,700;0,800;1,300;1,400;1,600;1,700;1,800&display=swap">
    <script>
        function addOnload(fun) {
            let last = window.onload;
            window.onload = function () {
                if (last) last();
                fun();
            }
        }
    </script>
</head>
<body>
<div class="page">
    <div class="top-bar-w">
        <div class="top-bar">
            
                <div class="logo"><a href="/"><img src="/logo.png" alt="Topological Sort - IamCoder Wiki" height="33"/></a></div>
            
            <div class="search-w">
                <div class="search-input-w hide"><label for="t-s-input"></label><input id="t-s-input" placeholder="검색">
                </div>
                <div class="search" id="t-s-button">
                    <div class="icon-w">
                        <i class="fas fa-search"></i>
                    </div>
                </div>
                <div class="search-result-w hide" id="t-search-result"></div>
            </div>
            <div class="theme-w" id="t-t-button">
                <div class="theme">
                    <i class="fas fa-sun fa-lg" id="t-t-icon"></i>
                </div>
            </div>
        </div>
    </div>
    <div class="content-w">
        <div class="content">
            <div class="main">
                <div class="header hl">
                    <div class="gh-buttons">
                        <a target="_blank" href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io/edit/master/src/topological-sort.md"><div class="button">편집</div></a>
                        <a target="_blank" href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io/commits/master/src/topological-sort.md"><div class="button">역사</div></a>
                        <a target="_blank" href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io/blob/master/src/topological-sort.md"><div class="button hs">Github에서 보기</div></a>
                        <a target="_blank" href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io/issues/new?title=%5BTopological Sort%5D+"><div class="button hs">토론 생성하기</div><div class="button hm">새 토론</div></a>
                        <a target="_blank" href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+%5BTopological Sort%5D"><div class="button hs">진행중인 토론</div><div class="button hm">토론 보기</div></a>
                    </div>
                    <p> 최근 수정 시각: 2020-08-16 21:30:14 </p>
                    <div class="contributors"> <div class="description"><span>기여자:&nbsp;</span></div><a href="https://github.com/retro3014" target="_blank"><span title="retro3014"><img src="https://github.com/retro3014.png?size=32" width="24" height="24" alt="@retro3014"/></span></a><a href="https://github.com/buttercrab" target="_blank"><span title="buttercrab"><img src="https://github.com/buttercrab.png?size=32" width="24" height="24" alt="@buttercrab"/></span></a> </div>
                </div>
                <main>
                    
<script>
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function writeTitle() {
    let s = ["T_", "To_", "Top_", "Topo_", "Topol_", "Topolo_", "Topolog_", "Topologi_", "Topologic_", "Topologica_", "Topological_", "Topological _", "Topological S_", "Topological So_", "Topological Sor_", "Topological Sort_", "Topological Sort_", "Topological Sort_", "Topological Sort_", "Topological Sort", "Topological Sort", "Topological Sort", "Topological Sort", "Topological Sort_", "Topological Sort_", "Topological Sort_", "Topological Sort_", "Topological Sort"];
    let title = document.getElementsByClassName('title')[0];
    for(let i in s) {
        title.innerHTML = s[i];
        await sleep(100);
    }
}

addOnload(writeTitle);
</script>
<h1 class="heading title">_</h1>
<h2 class="heading"><a href="#s-1-" id="s-1-">1.</a> 소개</h2>
<p>Topological Sort는 위상 정렬이라고 하며, 방향 그래프에서 정점들을 정점 u에서 정점 v로 가는 간선이 있을 때, 정점 u가 정점 v보다 앞에 오도록 선형으로 정렬하는 것입니다. 이렇게 정점들을 정렬하면 어떤 작업을 수행할 때 올바른 순서를 알아낼 수 있습니다. 예를 들어, 수강해야 할 여러 수업들 중 한 수업보다 먼저 들어야 하는 수업이 있을 때, 위상 정렬을 이용하면 가능한 수강 순서를 알아낼 수 있을 것입니다. 그러나 이러한 위상 정렬을 하려면, 정렬하려고 하는 그래프가 사이클이 없는 방향성 비순환 그래프 (directed acyclic graph 또는 DAG) 이어야 합니다. 당연하게도 사이클이 존재한다면 사이클을 이루는 정점 간의 우선 순위를 결정할 수 없기 때문입니다. 그리고 정렬이 된 순서는 그래프의 구조에 따라 여러 종류가 나올 수 있게 됩니다.</p>
<p>실제 컴퓨터 분야에서 이 알고리즘은 논리 합성, 데이터 직렬화, 코드 최적화의 한 방법인 Instruction Scheduling 등에서 사용됩니다. </p>
<h2 class="heading"><a href="#s-2-" id="s-2-">2.</a> Kahn's Algorithm</h2>
<p>가장 대표적이고 많이 쓰이는 위상 정렬 알고리즘은 Kahn 이라는 사람이 처음 설명했다고 합니다. 먼저 indegree_(진입 차수 : 한 정점으로 향하는 간선의 개수)_가 0인 정점을 모두 찾습니다. 그리고 이 정점들을 그래프에서 제거합니다. 제거함에 따라 생기는 indegree가 0인 정점들을 다시 찾아 위 두 과정을 반복합니다. 이 과정을 그래프에서 정점이 없어질 때까지 수행한 뒤, 제거했던 순서대로 정점을 배열하면 위상 정렬이 완료됩니다. 이를 구현해보면 다음과 같습니다. 여기서 L은 앞으로 정렬된 정점 번호가 들어갈 배열이고, 현재는 비어있습니다. S는 queue 이고 정점 중 가리키는 간선의 개수가 0인 정점이 들어가게 됩니다.</p>
<pre><code class="language-c++">for(n : node){
 if(indegree[n]==0){
   S.push_back(n);
 }
}
while(!S.empty()){
 n = S.back(); S.pop_back();
 L.push_back(n);
 for(m : graph[n]){
   indegree[m]--;
   if(indegree[m]==0){
     S.push_back(m);
   }
 }
}
if(L.size()!=N)	return error;	// graph has at least one cycle
else	return L;	// a topologically sorted order
</code></pre>
<p>이 알고리즘은 시간복잡도가 \(O(V+E)\)로, 정점의 개수와 간선의 개수를 더한 것이 됩니다. 그 이유는 <code>S</code>에서 노드를 총 <code>n</code>번 꺼내게 되어 \(O(V)\), 모든 간선을 한 번씩 제거해서 \(O(E)\)가 되기 때문입니다.</p>
<h2 class="heading"><a href="#s-3-" id="s-3-">3.</a> Using DFS</h2>
<p>잘 알려진 깊이 우선 탐색(dfs, depth-first search)을 이용해도 위상 정렬을 할 수 있습니다. 그러나 dfs를 시작하는 정점은 꼭 indegree가 0인 정점이 아니어도 되고, 재귀호출을 한 함수가 끝날 때 값을 배열 L에 넣으면 됩니다. 이 때 위상 정렬한 결과는 배열 L에서 역순으로 뒤집어 준 것과 같다는 점을 유의해야 합니다. 그래서 배열 대신 Stack이라는 자료 구조를 활용하는 것도 가능합니다. 이를 구현해보면 다음과 같습니다.</p>
<pre><code class="language-c++">void visit(Node n){
  if(per[n])	return;
  if(tem[n])	stop();		// not DAG
  tem[n] = true;
  for(m : graph[n]){
    visit(m);
  }
  tem[n] = false;
  per[n] = true;
  L.push_back(L);
}

void topological_sort(){
  for(n : node){
    if(!per[n]){
      visit(n);
    }
  }
  return L;
}
</code></pre>
<p>이 코드의 시간복잡도는 위와 마찬가지로 선형인 \(O(n)\)입니다. 그러나 위의 코드보다는 조금 오래 걸릴 것입니다. 또한 이 알고리즘은 직관적인 이해가 보다 쉽지 않습니다. 그래서 일반적으로 위상 정렬만 할 경우에는 위의 알고리즘을 쓰게 됩니다. 그러나 dfs를 활용해서도 위상 정렬을 할 수 있다는 사실 정도는 알아두면 좋을 것입니다.</p>
<h2 class="heading"><a href="#s-4-" id="s-4-">4.</a> Finding a Shortest Path</h2>
<p>위상 정렬을 이용하면 DAG에서 최단 경로도 빠르게 찾아낼 수 있습니다. 위상 정렬을 한 결과를 저장한 배열이 있을 때 배열 위의 정점 s에서 배열 끝까지, 각 정점마다 간선으로 연결된 다른 정점까지의 최단 경로를 갱신해주면 됩니다. 이를 구현해보면 다음과 같습니다. 여기서 배열 <code>V</code>는 위상 정렬을 한 결과가 들어가있고, 배열 <code>d[u]</code>에는 정점 <code>s</code>에서 정점 <code>u</code>까지의 최단 경로가 들어가게 될 것입니다. 그리고 <code>w</code>는 <code>u</code>에서 <code>v</code>로 향하는 간선의 가중치를 의미합니다.</p>
<pre><code class="language-c++">d[s] = 0;

for(u : node){
   if(u!=s)	d[u] = INF;
}

for(u : V){
 for(v : graph[u]){
   if(d[v] &gt; d[u] + w)	d[v] = d[u] + w;
 }
}
</code></pre>
<p>이 알고리즘은 위상 정렬을 할 때와 마찬가지로 시간복잡도가 \(O(V+E)\)입니다. 따라서 선형이므로 꽤나 빠르게 최단 경로를 찾을 수 있습니다. 그러나 이와 비슷한 시간복잡도를 가지고 좀 더 간결하게 코드를 짤 수 있는 dijkstra 알고리즘을 사용하는 것이 실전에서는 더 도움이 될 것입니다.</p>
<h2 class="heading"><a href="#s-5-" id="s-5-">5.</a> 예시</h2>
<p>위상 정렬을 사용하여 해결할 수 있는 문제 중 대표적인 문제로는 <a href="https://www.acmicpc.net/problem/2252" class="outer" target="_blank">줄 세우기</a>가 있습니다. 이 문제는 vector 자료구조로 인접 리스트를 만들어 위상 정렬을 수행하면 바로 답을 구할 수 있습니다. 이에 대한 코드는 다음과 같습니다.</p>
<pre><code class="language-c++">int main(void) {
   for(i = 1; i &lt;= m; i++) {
   	scanf(&quot;%d %d&quot;, &amp;p, &amp;q);
   	V[p].push_back(q);
   	idg[q]++;
   }
   for(i = 1; i &lt;= n; i++)
   	if(idg[i] == 0)
   		Q.push(i);
 
   while(!Q.empty()) {
     u = Q.front();
     Q.pop();
     ans[++cnt] = u;
     siz = V[u].size();
     for(i = 0; i &lt; siz; i++) {
       v = V[u][i];
       idg[v]--;
       if(idg[v] == 0)
         Q.push(v);
     }
   }

   for(i = 1; i &lt;= cnt; i++)
     printf(&quot;%d &quot;, ans[i]);
   
   return 0;
}
</code></pre>

                </main>
            </div>
            <div class="side-bar hm hs">
                <nav class="toc"><ul><li><a href="#s-1-">1. 소개</a></li><li><a href="#s-2-">2. Kahn's Algorithm</a></li><li><a href="#s-3-">3. Using DFS</a></li><li><a href="#s-4-">4. Finding a Shortest Path</a></li><li><a href="#s-5-">5. 예시</a></li></ul></nav>
                <svg class="toc-marker" width="200" height="200" xmlns="http://www.w3.org/2000/svg">
                    <path id="toc-path" stroke-width="2" fill="transparent" stroke-dasharray="0, 0, 0, 1000"
                          stroke-linecap="round" stroke-linejoin="round" transform="translate(-0.5, -0.5)"/>
                </svg>
                <p> 최근 수정 시각: 2020-08-16 21:30:14 </p>
                <div class="contributors"> <div class="description"><span>기여자:&nbsp;</span></div><a href="https://github.com/retro3014" target="_blank"><span title="retro3014"><img src="https://github.com/retro3014.png?size=32" width="24" height="24" alt="@retro3014"/></span></a><a href="https://github.com/buttercrab" target="_blank"><span title="buttercrab"><img src="https://github.com/buttercrab.png?size=32" width="24" height="24" alt="@buttercrab"/></span></a> </div>
                <div class="gh-buttons">
                    <a target="_blank" href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io/edit/master/src/topological-sort.md"><div class="button">편집</div></a>
                    <a target="_blank" href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io/commits/master/src/topological-sort.md"><div class="button">역사</div></a>
                    <a target="_blank" href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io/blob/master/src/topological-sort.md"><div class="button">Github에서 보기</div></a>
                    <a target="_blank" href=https://github.com/iamcoder-wiki/iamcoder-wiki.github.io/issues/new?title=%5BTopological Sort%5D+"><div class="button">토론 생성하기</div></a>
                    <a target="_blank" href="https://github.com/iamcoder-wiki/iamcoder-wiki.github.io/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+%5BTopological Sort%5D"><div class="button">진행중인 토론</div></a>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="/r/js/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script src="https://unpkg.com/@popperjs/core@2"></script>
<script src="https://unpkg.com/tippy.js@6"></script>
<script type="text/javascript" src="/r/js/wiki.js"></script>
<script>
    function footnote() {
        let map = {};
        let def = document.getElementsByClassName("footnote-definition");

        for (let i = 0; i < def.length; i++) {
            let id = def[i].id.substr(2);
            map[id] = `<sup class="footnote-reference"><a href="#f-` + id + `">` + id + `</a></sup>` + def[i].children[1].innerHTML;
        }

        let ref = document.getElementsByClassName("footnote-reference");

        for (let i = 0; i < ref.length; i++) {
            let id = ref[i].children[0].id;
            let content = map[id.substr(2)];
            tippy(ref[i], {
                theme: 'footnote',
                content: content,
                allowHTML: true,
                interactive: true,
                interactiveBorder: 5,
            });
        }
    }

    window.MathJax = {
        startup: {
            ready: () => {
                MathJax.startup.defaultReady();
                MathJax.startup.promise.then(footnote);
            }
        }
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <!-- Google Analytics -->
    <script>
        (function (i, s, o, g, r, a, m) {
            i['GoogleAnalyticsObject'] = r;
            i[r] = i[r] || function () {
                (i[r].q = i[r].q || []).push(arguments)
            }, i[r].l = 1 * new Date();
            a = s.createElement(o),
                    m = s.getElementsByTagName(o)[0];
            a.async = 1;
            a.src = g;
            m.parentNode.insertBefore(a, m)
        })(window, document, 'script', 'https://www.google-analytics.com/analytics.js', 'ga');

        ga('create', 'UA-174669347-1', 'auto');
        ga('send', 'pageview');
    </script>
    <!-- End Google Analytics -->

</body>
</html>