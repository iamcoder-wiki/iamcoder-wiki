# Bitmask



## 소개

그럼 이제 본격적으로 비트마스킹이 뭔지 설명할 차례입니다. 비트마스킹에는 [비트 연산자](../bitoperator/bitoperator.md)가 모든 연산을 차지합니다. 먼저 비트마스크(Bitmask)의 정의부터 살펴봅시다. 비트마스크란, 비트를 변경하여 정보를 저장하는 정수를 뜻합니다. 비트마스킹 기법은 이 비트마스크를 사용하여 메모리 및 연산속도를 대폭 줄일 수 있습니다.

 ## 장점

비트마스크는 다음과 같은 주요 장점이 있습니다.

* __메모리 사용량의 큰 단축__

  비트마스크는 하나의 bool연산자를 하나의 비트로 대체할 수 있습니다. 실제 하나의 int형 정수는 32비트이므로, bool 연산자 32개(\\(2 \times 32 = 64\\)(byte))를 int형 정수 1개(4(byte))로 줄일 수 있습니다. 그렇게 함으로써, 긴 bool 배열을 짧은 정수배열로 바꾸어 메모리를 16배 가량 줄일 수 있게 해줍니다.

* __실행시간의 단축__

  실제로 연산 `4 * 2`와 `4 << 1`은 차이가 눈에 띄게 있지 않습니다. 그러나 이 연산이 몇천번정도 반복된다면 이야기가 달라집니다. 일반적인 사칙연산은 비트연산을 여러번 진행한 다음 그 결과값을 반환하지만 비트연산은 딱 한번의 연산만 필요하기 때문에 실행시간을 많게는 반 가량 단축시킬 수 있습니다.

* __코드 길이의 단축__

  비트마스크를 쓸 경우 복잡한 코드가 한주로 짧게 줄어들 수 있습니다. 비트마스킹만 잘 안다면, 코드의 가독성이 향상될 것입니다.

## 코드

비트마스킹으로 배열에 있는 많은 기능들을 구현해 봅시다. 대부분의 구현들이 간단한 비트연산 한번으로 가능합니다. 다음 코드를 봅시다.

``` c++
#include <bits/stdc++.h> 

int Bitmask;

int main(){
    Bitmask = 10; //이진수로 1010
    int n, tmp = Bitmask;
    scanf("%d", &n);
    if(Bitmask & (1 << n)) printf("arr[%d] is true.\n", n); //원소의 존재 확인, 저기서 1과 같냐는 조건을 추가한다면 제대로 동작하지 않습니다.
    
    scanf("%d", &n);
    Bitmask |= (1 << n); //원소 추가
    printf("%dth(st, nd, rd) element added.\n", n);
  
    scanf("%d", &n);
    Bitmask &= ~(1 << n); //원소 삭제, 만약 원소가 없으면 그대로
    printf("%dth(st, nd, rd) element deleted.(if in array)", n);
    
    scanf("%d", &n);
    Bitmask ^= (1 << n); //원소 토글, if문이 필요 없습니다.
    printf("%dth(st, nd, rd) element toggled.", n);

    int Union = (Bitmask | tmp); //합집합, for문 불필요
    
    int Intersection = (Bitmask & tmp); //교집합
    
    int Relative_Component = (Bitmask & ~tmp); //차집합
    
    int Symmetric_Difference = (Bitmask ^ tmp) //대칭차집합
    
    int Complement_Set = ~Bitmask //여집합

    int Min_element = (Bitmask & -Bitmask); //최소원소

    Bitmask &= (Bitmask - 1); //최소원소 지우기

    for(int Sub = Bitmask, i = 1; Sub; Sub = ((Sub - 1) & Bitmask), i++){
        printf("Subset %d: %d", i, Sub); //모든 부분집합 순회
    }

    //비트마스킹을 사용할 때는 모든 비트 연산의 주변에 괄호를 치는 것을 추천합니다. 잘못하면 연산자 우선순위 때문에 어이없는 오류가 날 수도 있기 떄문입니다.

}
```



## 코드 설명

차근차근 짚어나가 보죠.  

### 원소 확인

원소 확인은 쉬프트 연산을 통해 1비트의 자리를 설정하고, AND연산을 하여 0인지 0이 아닌 다른 값인지 확인해 줍니다. 이떄, AND연산의 결과가 꼭 1은 아닙니다. 왜냐하면 AND연산은 참 거짓이 아닌 계산의 결과값, 즉 그 자리에 비트가 있다면 2의 거듭제곱을 반환하기 떄문입니다. 

### 원소 추가

OR연산을 통해 원소를 추가해 줍니다. 설령 이미 원소가 있더라도, 원소는 다르게 바뀌지 않습니다. 있으면 항상 1이기 때문에 1이 1로 바뀌는 것일 뿐입니다. 즉, 변화가 없습니다. 

### 원소 삭제

AND연산을 통해 원소를 삭제해 줍니다. 삭제할 위치의 비트만 1인 상태에서 NOT연산을 취해 준다면 비트가 반전되어 그 비트만 삭제됩니다. 설령 원소가 이미 없더라도 괜찮습니다. 마찬가지로 0이 그대로 0으로 갱신되는 것 뿐입니다. 

### 원소 반전(토글)

XOR연산으로 원소를 토글해줍니다. 원소가 1이면 0으로, 0이면 1으로 바꿔준다는 것을 쉽게 알 수 있습니다. 여기서 눈여겨봐야 할 점은, 조건문이 전혀 필요없다는 것입니다. 비트연산 하나로 간단하게 끝낼 수 있다는 점, 이게 바로 비트마스킹의 장점입니다. 

### 합집합

두 집합 사이 OR연산으로 원소가 둘 중 한곳이라도 있다면 전부 있음으로 표시하여 합집합을 계산합니다. 

### 교집합

두 집합 사이 AND연산으로 원소가 두 곳 모두 있다면 있음으로 표시하여 교집합을 계산합니다. 

### 차집합

한 집합을 비트반전(NOT) 반전한 다음 AND 연산으로 원소가 반전한 집합과 반전하지 않은 집합 둘 다 있다면 전부 있음으로 표시하여 차집합을 계산합니다. 

### 대칭차집합

두 집합 사이 XOR연산으로 원소의 유무가 다르다면 전부 있음으로 표시하여 대칭차집합을 계산합니다. 

### 여집합

NOT연산으로 원소를 반전하여 여집합을 계산합니다.

### 최소 원소 찾기

최소원소 찾기는 비트마스킹의 장점을 다시 한번 보여주는 좋은 예입니다. 위 식은 보수를 이용한 것으로, 보수가 `-N-1`으로 표현가능함을 이용하여 가장 작은 원소를 손쉽게 계산할 수 있습니다.

또한, 1을 빼면 최소원소 직전의 0들은 모두 1로 반전되고 최소비트 하나만 0으로 반전되기 떄문에 최소비트를 빠르게 뺄 수 있습니다. 최소 원소를 구하고 반전시키는 것보다 훨씬 빠릅니다. 

### 시간복잡도

여기까지 모든 연산의 시간복잡도는 모두 \\(O(1)\\)입니다.

### 부분집합 순회 

마지막으로 부분집합 순회입니다. 저 순회는 다른거에 비해 굉장히 강력합니다. 매우 간단하게 모든 부분집합을 탐색하는 코드를 만들 수 있기 떄문이죠. 먼저 1을 뺀다면 최하위 비트와 그 밑의 0들은 전부 반전됩니다. 그 후 원래 집합과의 교집합을 구한다면, 그 원집합에 속하지 않는 원소들은 모두 꺼지게 됩니다. 그리하여 모든 부분집합을 탐색해나갈 수 있습니다.

시간복잡도는 \\(O(2^{N})\\)입니다.

## 예제

비트마스킹은 주로 동적계획법, 즉 다이나믹 프로그래밍과 같이 자주 쓰입니다. 다음 예제를 봅시다. 이 문제는 백준 OJ의 [외판원 순회](https://www.acmicpc.net/problem/2098) 문제입니다.

>외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.
>
>1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.
>
>각 도시간에 이동하는데 드는 비용은 행렬 `W[i][j]`형태로 주어진다. `W[i][j]`는 도시 `i`에서 도시 `j`로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, `W[i][j]` 는 `W[j][i]`와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. `W[i][i]`는 항상 0이다. 경우에 따라서 도시 `i`에서 도시 `j`로 갈 수 없는 경우도 있으며 이럴 경우 `W[i][j] = 0`이라고 하자.
>
>N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.
>
>----
>
>__입력__
>
>첫째 줄에 도시의 수 `N`이 주어진다. (\\(2 \leq N \leq 16)\\) 다음 `N`개의 줄에는 비용 행렬이 주어진다. 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다. `W[i][j]`는 도시 `i`에서 `j`로 가기 위한 비용을 나타낸다.
>
>항상 순회할 수 있는 경우만 입력으로 주어진다.
>
>----
>
>__출력__
>
>첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.
>
>----
>
>__입출력 예시__
>
>----
>
>___Input___
>
>_4_
>
>_0 10 15 20_
>
>_5  0  9 10_
>
>_6 13  0 12_
>
>_8  8  9  0_
>
>____
>
>___Output___
>
>_35_

이 문제의 풀이 방법은 비트마스크와 다이나믹 프로그래밍입니다. 먼저 시작 도시를 정한 후, 그 도시로 부터 갈 수 있는 방법을 완전탐색 해 나갑니다. 이떄, 그냥 일반적인 완전탐색은 시간이 엄청나게 오래 걸리므로, 다이나믹 프로그래밍을 사용합니다. 점화식은 다음과 같습니다.

 

\\(TSP(curr, visited) = min(TSP(next, visited \cup next) + dist[curr][next]) \\)

\\((0 \leq next \leq N - 1, next \neq curr, next \notin visited)\\)

 

현재 도시의 순회 최솟값을 알기 위해 다음 돌아가는 모든 경로를 탐색한 후 그 값을 DP에 저장하면 문제가 풀릴 수 있습니다. 이떄, 집합 visited를 비트마스킹으로 구현할 수 있습니다.

이 코드는 DP의 원소의 개수가 \\(2^{N} \times N\\)이고 이를 각 도시마다 한 번씩 N번 탐색하여 총 시간복잡도는 \\(O(2^{N} \times N^{2})\\)입니다. 만약 다이나믹기법을 쓰지 않았다면 모두 일일이 탐색해야 하므로 시간복잡도는 \\(O(N!)\\)이 되었을 것입니다. 느리기는 하지만, 확실히 빨라졌습니다. 여기에 비트마스킹으로 연산속도까지 빨라졌으니, 문제에서 주어진 `N`의 범위쯤은 거뜬합니다.

